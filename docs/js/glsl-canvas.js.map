{"version":3,"names":[],"mappings":"","sources":["src/glsl-canvas/glsl-canvas.ts"],"sourcesContent":["// import '@babel/polyfill';\nimport 'whatwg-fetch';\nimport Buffers from './buffers';\nimport Context, { ContextVertexBuffers } from './context';\nimport ListenerSubscriber from './listener.subscriber';\nimport Textures, { Texture, TextureExtensions } from './textures';\nimport Uniforms, { Uniform } from './uniforms';\n\nconst GlslCanvasDefaultVertex = `\n#ifdef GL_ES\nprecision mediump float;\n#endif\n\nattribute vec2 a_position;\nattribute vec2 a_texcoord;\n\nvarying vec2 v_texcoord;\n\nvoid main(){\n\tgl_Position = vec4(a_position, 0.0, 1.0);\n\tv_texcoord = a_texcoord;\n}\n`;\n\nconst GlslCanvasDefaultFragment = `\n#ifdef GL_ES\nprecision mediump float;\n#endif\n\nvarying vec2 v_texcoord;\n\nvoid main(){\n\tgl_FragColor = vec4(0.0);\n}\n`;\n\nexport interface ICanvasContextOptions {\n    backgroundColor?: string;\n    vertexString?: string;\n    fragmentString?: string;\n    alpha?: GLboolean;\n    antialias?: GLboolean;\n    depth?: GLboolean;\n    failIfMajorPerformanceCaveat?: boolean;\n    // powerPreference?: WebGLPowerPreference;\n    premultipliedAlpha?: GLboolean;\n    preserveDrawingBuffer?: GLboolean;\n    stencil?: GLboolean;\n}\n\nexport interface IPoint {\n    x: number,\n    y: number,\n}\n\nexport class GlslCanvasOptions {\n\n}\n\nexport class GlslCanvasTimer {\n    start: number;\n    previous: number;\n    delay: number = 0.0;\n    current: number = 0.0;\n    delta: number = 0.0;\n    paused: boolean = false;\n\n    constructor() {\n        this.start = this.previous = performance.now() / 1000.0;\n    }\n\n    play() {\n        if (this.previous) {\n            const now = performance.now() / 1000.0;\n            this.delay += (now - this.previous);\n            this.previous = now;\n        }\n        // console.log(this.delay);\n        this.paused = false;\n    }\n\n    pause() {\n        this.paused = true;\n    }\n\n    next(): GlslCanvasTimer {\n        const now = performance.now() / 1000.0;\n        this.delta = now - this.previous;\n        this.current = now - this.start - this.delay;\n        this.previous = now;\n        return this;\n    }\n\n}\n\nexport default class GlslCanvas extends ListenerSubscriber {\n\n    canvas: HTMLCanvasElement;\n    width: number;\n    height: number;\n    timer: GlslCanvasTimer;\n    dirty: boolean = true;\n\n    animated: boolean = false;\n    nDelta: number = 0;\n    nTime: number = 0;\n    nDate: number = 0;\n    nMouse: number = 0;\n\n    pixelRatio: number;\n    gl: WebGLRenderingContext;\n    program: WebGLProgram;\n    textureList: any[] = [];\n    textures: Textures = new Textures();\n    buffers: Buffers = new Buffers();\n    uniforms: Uniforms = new Uniforms();\n    vertexBuffers: ContextVertexBuffers;\n    rect: ClientRect | DOMRect;\n    mouse: IPoint = { x: 0, y: 0 };\n    valid: boolean = false;\n    visible: boolean = false;\n    vertexString: string;\n    fragmentString: string;\n    resize: Function;\n    scroll: Function;\n    mousemove: Function;\n    click: Function;\n    loop: Function;\n\n    constructor(\n        canvas: HTMLCanvasElement,\n        contextOptions: ICanvasContextOptions = {},\n        options: any = {}\n    ) {\n        super();\n        if (!canvas) {\n            return;\n        }\n        this.canvas = canvas;\n        this.width = canvas.clientWidth;\n        this.height = canvas.clientHeight;\n        this.rect = canvas.getBoundingClientRect();\n        this.vertexString = contextOptions.vertexString || GlslCanvasDefaultVertex;\n        this.fragmentString = contextOptions.fragmentString || GlslCanvasDefaultFragment;\n        const gl = Context.tryGetContext(canvas, contextOptions, options.onError);\n        if (!gl) {\n            return;\n        }\n        this.gl = gl;\n        this.pixelRatio = window.devicePixelRatio || 1;\n        canvas.style.backgroundColor = contextOptions.backgroundColor || 'rgba(0,0,0,0)';\n        this.getShaders().then(\n            (success) => {\n                this.load();\n                if (!this.program) {\n                    return;\n                }\n                this.addListeners();\n                this.loop();\n                // this.animated = false;\n            },\n            (error) => {\n                console.log('error', error);\n            });\n    }\n\n    static version(): string {\n        return '0.1.8';\n    }\n\n    static isDifferent(a: any, b: any): boolean {\n        if (a && b) {\n            return a.toString() !== b.toString();\n        }\n        return false;\n    }\n\n    getShaders(): Promise<string[]> {\n        return new Promise((resolve, reject) => {\n            const canvas = this.canvas;\n            const urls = [];\n            if (canvas.hasAttribute('data-vertex-url')) {\n                urls.push(canvas.getAttribute('data-vertex-url'));\n            }\n            if (canvas.hasAttribute('data-fragment-url')) {\n                urls.push(canvas.getAttribute('data-fragment-url'));\n            }\n            if (urls.length) {\n                Promise.all(urls.map((url, i) =>\n                    fetch(url)\n                        .then((response) => response.text())\n                        .then((body) => {\n                            if (i === 0) {\n                                return this.vertexString = body;\n                            } else {\n                                return this.fragmentString = body;\n                            }\n                        })\n                )).then(shaders => {\n                    resolve(shaders);\n                });\n            } else {\n                if (canvas.hasAttribute('data-vertex')) {\n                    this.vertexString = canvas.getAttribute('data-vertex');\n                }\n                if (canvas.hasAttribute('data-fragment')) {\n                    this.fragmentString = canvas.getAttribute('data-fragment');\n                }\n                resolve([this.vertexString, this.fragmentString]);\n            }\n        });\n    }\n\n    addListeners(): void {\n        // resize buffers on canvas resize\n        // consider applying a throttle of 50 ms on canvas resize\n        // to avoid requestAnimationFrame and Gl violations\n        const resize = (e: Event) => {\n            this.rect = this.canvas.getBoundingClientRect();\n        };\n\n        const scroll = (e: Event) => {\n            this.rect = this.canvas.getBoundingClientRect();\n        };\n\n        const mousemove = (e: MouseEvent) => {\n            this.mouse.x = e.clientX || e.pageX;\n            this.mouse.y = e.clientY || e.pageY;\n        };\n\n        const click = (e: MouseEvent) => {\n            this.toggle();\n        };\n\n        const loop: FrameRequestCallback = (time: number) => {\n            this.checkRender();\n            window.requestAnimationFrame(loop);\n        };\n\n        this.resize = resize;\n        this.scroll = scroll;\n        this.mousemove = mousemove;\n        this.click = click;\n        this.loop = loop;\n\n        window.addEventListener('resize', resize);\n        window.addEventListener('scroll', scroll);\n        document.addEventListener('mousemove', mousemove, false);\n        if (this.canvas.hasAttribute('controls')) {\n            this.canvas.addEventListener('click', click);\n            if (!this.canvas.hasAttribute('autoplay')) {\n                this.pause();\n            }\n        }\n    }\n\n    load(\n        fragmentString?: string,\n        vertexString?: string\n    ): void {\n        if (vertexString) {\n            this.vertexString = vertexString;\n        }\n        if (fragmentString) {\n            this.fragmentString = fragmentString;\n        }\n        const gl = this.gl;\n        const vertexShader = Context.createShader(gl, this.vertexString, gl.VERTEX_SHADER);\n        let fragmentShader = Context.createShader(gl, this.fragmentString, gl.FRAGMENT_SHADER);\n        // If Fragment shader fails load a empty one to sign the error\n        if (!fragmentShader) {\n            fragmentShader = Context.createShader(gl, `void main(){\n\t\t\t\tgl_FragColor = vec4(1.0);\n\t\t\t}`, gl.FRAGMENT_SHADER);\n            this.valid = false;\n        } else {\n            this.valid = true;\n        }\n        // Create and use program\n        const program = Context.createProgram(gl, [vertexShader, fragmentShader]); //, [0,1],['a_texcoord','a_position']);\n        gl.useProgram(program);\n        // Delete shaders\n        // gl.detachShader(program, vertexShader);\n        // gl.detachShader(program, fragmentShader);\n        gl.deleteShader(vertexShader);\n        gl.deleteShader(fragmentShader);\n        this.program = program;\n        if (this.valid) {\n            this.buffers = Buffers.getBuffers(gl, this.fragmentString, this.vertexString);\n            this.vertexBuffers = Context.createVertexBuffers(gl, program);\n            this.createUniforms();\n            // this.getBuffers(this.fragmentString);\n        }\n        // Trigger event\n        this.trigger('load', {});\n        // this.render();\n    }\n\n    test(\n        fragmentString?: string,\n        vertexString?: string\n    ): Promise<any> {\n        return new Promise((resolve, reject) => {\n            // Thanks to @thespite for the help here\n            // https://www.khronos.org/registry/webgl/extensions/EXT_disjoint_timer_query/\n            const vertex = this.vertexString;\n            const fragment = this.fragmentString;\n            const paused = this.timer.paused;\n            const extension = this.gl.getExtension('EXT_disjoint_timer_query');\n            const query = extension.createQueryEXT();\n            let wasValid = this.valid;\n            if (fragmentString || vertexString) {\n                this.load(fragmentString, vertexString);\n                wasValid = this.valid;\n                this.render();\n            }\n            this.timer.paused = true;\n            extension.beginQueryEXT(extension.TIME_ELAPSED_EXT, query);\n            this.render();\n            extension.endQueryEXT(extension.TIME_ELAPSED_EXT);\n            const waitForTest = () => {\n                this.render();\n                const available = extension.getQueryObjectEXT(query, extension.QUERY_RESULT_AVAILABLE_EXT);\n                const disjoint = this.gl.getParameter(extension.GPU_DISJOINT_EXT);\n                if (available && !disjoint) {\n                    const result = {\n                        wasValid: wasValid,\n                        fragment: fragmentString || this.fragmentString,\n                        vertex: vertexString || this.vertexString,\n                        timeElapsedMs: extension.getQueryObjectEXT(query, extension.QUERY_RESULT_EXT) / 1000000.0\n                    };\n                    this.timer.paused = paused;\n                    if (fragmentString || vertexString) {\n                        this.load(fragment, vertex);\n                    }\n                    resolve(result);\n                } else {\n                    window.requestAnimationFrame(waitForTest);\n                }\n            }\n            waitForTest();\n        });\n    }\n\n    destroy(): void {\n        this.animated = false;\n        this.valid = false;\n        const gl = this.gl;\n\t\t/*\n\t\t// !!!\n\t\tfor (let texture in this.textures) {\n\t\t\tif (texture.destroy) {\n\t\t\t\ttexture.destroy(gl);\n\t\t\t}\n\t\t}\n\t\t*/\n        gl.useProgram(null);\n        gl.deleteProgram(this.program);\n        this.buffers.forEach(buffer => buffer.destroy(gl));\n        this.buffers = null;\n        this.textures = null;\n        this.uniforms = null;\n        this.program = null;\n        this.gl = null;\n    }\n\n    setUniform(key: string, ...values: any[]): void {\n        const uniform: Uniform = Uniforms.parseUniform(key, ...values);\n        if (uniform) {\n            if (uniform.type === 'sampler2D') {\n                this.loadTexture(key, values[0]);\n            } else {\n                this.uniforms.set(key, uniform);\n            }\n        }\n    }\n\n    setUniforms(values: Map<string, any[]>): void {\n        values.forEach((value: any[], key: string) => {\n            this.setUniform(key, ...value);\n        });\n    }\n\n    pause(): void {\n        this.timer.pause();\n        this.canvas.classList.add('paused');\n    }\n\n    play(): void {\n        this.timer.play();\n        this.canvas.classList.remove('paused');\n    }\n\n    toggle(): void {\n        if (this.timer.paused) {\n            this.play();\n        } else {\n            this.pause();\n        }\n    }\n\n    isVisible(): boolean {\n        const rect = this.rect;\n        return (rect.top + rect.height) > 0 && rect.top < (window.innerHeight || document.documentElement.clientHeight);\n    }\n\n    isAnimated(): boolean {\n        return (this.animated || this.textures.animated) && !this.timer.paused;\n    }\n\n    isDirty(): boolean {\n        return this.dirty || this.uniforms.dirty || this.textures.dirty;\n        // Array.from(this.textures.values()).reduce((p, texture) => p || texture.dirty, false);\n        // this.textures.dirty;\n    }\n\n    // !!!\n    sizeDidChanged(): boolean {\n        const gl = this.gl;\n        const rect = this.rect;\n        const W = rect.width,\n            H = rect.height;\n        if (this.width !== W ||\n            this.height !== H) {\n            this.width = W;\n            this.height = H;\n            // Lookup the size the browser is displaying the canvas in CSS pixels\n            // and compute a size needed to make our drawingbuffer match it in\n            // device pixels.\n            const BW = Math.floor(W * this.pixelRatio);\n            const BH = Math.floor(H * this.pixelRatio);\n            // Check if the canvas is not the same size.\n            if (gl.canvas.width !== BW ||\n                gl.canvas.height !== BH) {\n                // Make the canvas the same size\n                gl.canvas.width = BW;\n                gl.canvas.height = BH;\n                // Set the viewport to match\n                // gl.viewport(0, 0, BW, BH);\n            }\n            this.buffers.forEach(buffer => {\n                buffer.resize(gl, BW, BH);\n            });\n            // gl.useProgram(this.program);\n            return true;\n        } else {\n            return false;\n        }\n    }\n\n    checkRender(): void {\n        if (this.isVisible() && (this.sizeDidChanged() || this.isAnimated() || this.isDirty())) {\n            this.render();\n            this.canvas.classList.add('playing');\n        } else {\n            this.canvas.classList.remove('playing');\n        }\n    }\n\n    createUniforms(): void {\n        const gl = this.gl;\n        const fragmentString = this.fragmentString;\n        const BW = gl.drawingBufferWidth;\n        const BH = gl.drawingBufferHeight;\n        const timer = this.timer = new GlslCanvasTimer();\n        const hasDelta = (fragmentString.match(/u_delta/g) || []).length > 1;\n        const hasTime = (fragmentString.match(/u_time/g) || []).length > 1;\n        const hasDate = (fragmentString.match(/u_date/g) || []).length > 1;\n        const hasMouse = (fragmentString.match(/u_mouse/g) || []).length > 1;\n        const hasTextures = this.parseTextures(fragmentString);\n        this.animated = hasTime || hasDate || hasMouse;\n        if (this.animated) {\n            this.canvas.classList.add('animated');\n        } else {\n            this.canvas.classList.remove('animated');\n        }\n        this.uniforms.create('2f', 'vec2', 'u_resolution', BW, BH);\n        if (hasDelta) {\n            this.uniforms.create('1f', 'float', 'u_delta', timer.delta);\n        }\n        if (hasTime) {\n            this.uniforms.create('1f', 'float', 'u_time', timer.current);\n        }\n        if (hasDate) {\n            const date = new Date();\n            this.uniforms.create('4f', 'float', 'u_date', date.getFullYear(), date.getMonth(), date.getDate(), date.getHours() * 3600 + date.getMinutes() * 60 + date.getSeconds() + date.getMilliseconds() * 0.001);\n        }\n        if (hasMouse) {\n            this.uniforms.create('2f', 'vec2', 'u_mouse', 0, 0);\n        }\n        this.buffers.forEach(buffer => {\n            this.uniforms.create('1i', 'sampler2D', buffer.key, buffer.input.index);\n        });\n        if (hasTextures) {\n            this.textureList.forEach(x => {\n                this.loadTexture(x.key, x.url);\n            });\n        }\n        /*\n        while (this.textureList.length > 0) {\n            const x = this.textureList.shift();\n            this.loadTexture(x.key, x.url);\n        }\n        */\n    }\n\n    parseTextures(fragmentString: string): boolean {\n        const hasTextures = fragmentString.search(/sampler2D/g);\n        if (hasTextures) {\n            const lines = fragmentString.split('\\n');\n            for (let i = 0; i < lines.length; i++) {\n                const match = lines[i].match(/uniform\\s*sampler2D\\s*([\\w]*);\\s*\\/\\/\\s*([\\w|\\:\\/\\/|\\.|\\-|\\_]*)/i);\n                if (match) {\n                    const ext = match[2].split('.').pop().toLowerCase();\n                    const key = match[1];\n                    const url = match[2];\n                    if (key && url && TextureExtensions.indexOf(ext) !== -1) {\n                        this.textureList.push({ key, url });\n                        // this.loadTexture(key, url);\n                    }\n                }\n                const main = lines[i].match(/\\s*void\\s*main\\s*/g);\n                if (main) {\n                    break;\n                }\n            }\n        }\n        if (this.canvas.hasAttribute('data-textures')) {\n            const urls = this.canvas.getAttribute('data-textures').split(',');\n            urls.forEach((url: string, i: number) => {\n                const key = 'u_tex' + i;\n                this.textureList.push({ key, url });\n                // this.loadTexture(key, url);\n            });\n        }\n        return this.textureList.length > 0;\n    }\n\n    loadTexture(key: string, url: string): Promise<Texture> {\n        if (this.valid) {\n            return this.textures.createOrUpdate(this.gl, key, url, this.buffers.count).then(texture => {\n                const index = texture.index;\n                const uniform = this.uniforms.createTexture(key, index);\n                uniform.texture = texture;\n                const uniformResolution = this.uniforms.create('2f', 'vec2', key + 'Resolution', texture.width, texture.height);\n                // console.log('loadTexture', key, url, index, texture.width, texture.height);\n                return texture;\n            });\n        } else {\n            this.textureList.push({ key, url });\n        }\n    }\n\n    updateUniforms(): void {\n        const gl = this.gl;\n        const BW = gl.drawingBufferWidth;\n        const BH = gl.drawingBufferHeight;\n        const timer = this.timer.next();\n        this.uniforms.update('2f', 'vec2', 'u_resolution', BW, BH);\n        if (this.uniforms.has('u_delta')) {\n            this.uniforms.update('1f', 'float', 'u_delta', timer.delta);\n        }\n        if (this.uniforms.has('u_time')) {\n            this.uniforms.update('1f', 'float', 'u_time', timer.current);\n        }\n        if (this.uniforms.has('u_date')) {\n            const date = new Date();\n            this.uniforms.update('4f', 'float', 'u_date', date.getFullYear(), date.getMonth(), date.getDate(), date.getHours() * 3600 + date.getMinutes() * 60 + date.getSeconds() + date.getMilliseconds() * 0.001);\n        }\n        if (this.uniforms.has('u_mouse')) {\n            const rect = this.rect;\n            const mouse = this.mouse;\n            if (mouse.x >= rect.left && mouse.x <= rect.right &&\n                mouse.y >= rect.top && mouse.y <= rect.bottom) {\n                const MX = (mouse.x - rect.left) * this.pixelRatio;\n                const MY = (this.canvas.height - (mouse.y - rect.top) * this.pixelRatio);\n                this.uniforms.update('2f', 'vec2', 'u_mouse', MX, MY);\n            }\n        }\n        this.buffers.forEach(buffer => {\n            this.uniforms.update('1i', 'sampler2D', buffer.key, buffer.input.index);\n        });\n        this.textures.forEach(texture => {\n            texture.tryUpdate(gl);\n            // console.log(texture.key, texture.index);\n            this.uniforms.update('1i', 'sampler2D', texture.key, texture.index);\n        });\n    }\n\n    render(): void {\n        const gl = this.gl;\n        const BW = gl.drawingBufferWidth;\n        const BH = gl.drawingBufferHeight;\n        this.updateUniforms();\n        this.buffers.forEach(buffer => {\n            this.uniforms.apply(gl, buffer.program);\n            buffer.render(gl, BW, BH);\n        });\n        gl.useProgram(this.program);\n        this.uniforms.apply(gl, this.program);\n        gl.viewport(0, 0, BW, BH);\n        gl.bindFramebuffer(gl.FRAMEBUFFER, null);\n        gl.drawArrays(gl.TRIANGLES, 0, 6);\n        this.uniforms.forEach(uniform => uniform.dirty = false);\n        this.uniforms.dirty = false;\n        this.textures.forEach(texture => texture.dirty = false);\n        this.textures.dirty = false;\n        this.dirty = false;\n        this.trigger('render', {});\n    }\n\n}\n\n(<any>window).GlslCanvas = GlslCanvas;\n\nconst loadAllGlslCanvas = () => {\n    const canvases: HTMLCanvasElement[] = <HTMLCanvasElement[]>Array.from(document.getElementsByClassName('glslCanvas')).filter(x => x instanceof HTMLCanvasElement);\n    (<any>window).glslCanvases = canvases.map(x => {\n        return new GlslCanvas(x);\n    }).filter(x => x.valid);\n}\n\nwindow.addEventListener('load', () => {\n    loadAllGlslCanvas();\n});\n"],"file":"glsl-canvas.js"}