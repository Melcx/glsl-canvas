{"version":3,"names":[],"mappings":"","sources":["src/glsl-canvas/glsl-canvas.ts"],"sourcesContent":["// import '@babel/polyfill';\n// import 'whatwg-fetch';\nimport 'promise-polyfill';\nimport Buffers, { IOBuffer } from './buffers';\nimport Common from './common';\nimport Context, { ContextDefaultFragment, ContextDefaultVertex, ContextVertexBuffers, IContextOptions } from './context';\nimport Subscriber from './subscriber';\nimport Textures, { Texture, TextureData, TextureExtensions } from './textures';\nimport Uniforms, { IUniformOption, Uniform, UniformMethod, UniformType } from './uniforms';\n\nexport interface IPoint {\n    x: number,\n    y: number,\n}\n\nexport class GlslCanvasOptions {\n    onError?: Function;\n}\n\nexport class GlslCanvasTimer {\n    start: number;\n    previous: number;\n    delay: number = 0.0;\n    current: number = 0.0;\n    delta: number = 0.0;\n    paused: boolean = false;\n\n    constructor() {\n        this.start = this.previous = performance.now() / 1000.0;\n    }\n\n    play() {\n        if (this.previous) {\n            const now = performance.now() / 1000.0;\n            this.delay += (now - this.previous);\n            this.previous = now;\n        }\n        // console.log(this.delay);\n        this.paused = false;\n    }\n\n    pause() {\n        this.paused = true;\n    }\n\n    next(): GlslCanvasTimer {\n        const now = performance.now() / 1000.0;\n        this.delta = now - this.previous;\n        this.current = now - this.start - this.delay;\n        this.previous = now;\n        return this;\n    }\n\n}\n\nexport default class GlslCanvas extends Subscriber {\n\n    canvas: HTMLCanvasElement;\n    width: number;\n    height: number;\n    timer: GlslCanvasTimer;\n    dirty: boolean = true;\n    animated: boolean = false;\n    nDelta: number = 0;\n    nTime: number = 0;\n    nDate: number = 0;\n    nMouse: number = 0;\n\n    pixelRatio: number;\n    gl: WebGLRenderingContext;\n    program: WebGLProgram;\n    textureList: any[] = [];\n    textures: Textures = new Textures();\n    buffers: Buffers = new Buffers();\n    uniforms: Uniforms = new Uniforms();\n    vertexBuffers: ContextVertexBuffers;\n    rect: ClientRect | DOMRect;\n    mouse: IPoint = { x: 0, y: 0 };\n    valid: boolean = false;\n    visible: boolean = false;\n    vertexString: string;\n    fragmentString: string;\n    loop: Function;\n    removeListeners: Function = () => { };\n\n    constructor(\n        canvas: HTMLCanvasElement,\n        contextOptions: IContextOptions = {},\n        options: GlslCanvasOptions = {}\n    ) {\n        super();\n        if (!canvas) {\n            return;\n        }\n        this.canvas = canvas;\n        this.width = canvas.clientWidth;\n        this.height = canvas.clientHeight;\n        this.rect = canvas.getBoundingClientRect();\n        this.vertexString = contextOptions.vertexString || ContextDefaultVertex;\n        this.fragmentString = contextOptions.fragmentString || ContextDefaultFragment;\n        const gl = Context.tryGetContext(canvas, contextOptions, options.onError);\n        if (!gl) {\n            return;\n        }\n        this.gl = gl;\n        this.pixelRatio = window.devicePixelRatio || 1;\n        canvas.style.backgroundColor = contextOptions.backgroundColor || 'rgba(0,0,0,0)';\n        this.getShaders().then(\n            (success) => {\n                this.load();\n                if (!this.program) {\n                    return;\n                }\n                this.addListeners();\n                this.loop();\n                // this.animated = false;\n            },\n            (error) => {\n                console.log('error', error);\n            });\n        GlslCanvas.items.push(this);\n    }\n\n    static items: GlslCanvas[] = [];\n\n    static version(): string {\n        return '0.2.0';\n    }\n\n    static isDifferent(a: any, b: any): boolean {\n        if (a && b) {\n            return a.toString() !== b.toString();\n        }\n        return false;\n    }\n\n    static of(canvas: HTMLCanvasElement): GlslCanvas {\n        return GlslCanvas.items.find(x => x.canvas === canvas) || new GlslCanvas(canvas);\n    }\n\n    static loadAll(): GlslCanvas[] {\n        const canvases: HTMLCanvasElement[] = <HTMLCanvasElement[]>[].slice.call(document.getElementsByClassName('glsl-canvas')).filter((x: HTMLElement) => x instanceof HTMLCanvasElement);\n        return canvases.map(x => GlslCanvas.of(x));\n    }\n\n    getShaders(): Promise<string[]> {\n        return new Promise((resolve, reject) => {\n            const canvas = this.canvas;\n            const urls: any = {};\n            if (canvas.hasAttribute('data-vertex-url')) {\n                urls.vertex = canvas.getAttribute('data-vertex-url');\n            }\n            if (canvas.hasAttribute('data-fragment-url')) {\n                urls.fragment = canvas.getAttribute('data-fragment-url');\n            }\n            if (canvas.hasAttribute('data-vertex')) {\n                this.vertexString = canvas.getAttribute('data-vertex');\n            }\n            if (canvas.hasAttribute('data-fragment')) {\n                this.fragmentString = canvas.getAttribute('data-fragment');\n            }\n            if (Object.keys(urls).length) {\n                Promise.all(Object.keys(urls).map((key, i) => {\n                    const url: string = urls[key];\n                    return Common.fetch(url)\n                        // .then((response) => response.text())\n                        .then((body) => {\n                            if (key === 'vertex') {\n                                return this.vertexString = body;\n                            } else {\n                                return this.fragmentString = body;\n                            }\n                        })\n                }\n                )).then(shaders => {\n                    resolve([this.vertexString, this.fragmentString]);\n                });\n            } else {\n                resolve([this.vertexString, this.fragmentString]);\n            }\n        });\n    }\n\n    addListeners(): void {\n        const resize = (e: Event) => {\n            this.rect = this.canvas.getBoundingClientRect();\n            this.trigger('resize', e);\n        };\n\n        const scroll = (e: Event) => {\n            this.rect = this.canvas.getBoundingClientRect();\n        };\n\n        const mousemove = (e: MouseEvent) => {\n            this.mouse.x = e.clientX || e.pageX;\n            this.mouse.y = e.clientY || e.pageY;\n            this.trigger('mousemove', e);\n        };\n\n        const click = (e: MouseEvent) => {\n            this.toggle();\n            this.trigger('click', e);\n        };\n\n        const mouseover = (e: MouseEvent) => {\n            this.play();\n            this.trigger('mouseover', e);\n        };\n\n        const mouseout = (e: MouseEvent) => {\n            this.pause();\n            this.trigger('mouseout', e);\n        };\n\n        const loop: FrameRequestCallback = (time: number) => {\n            this.checkRender();\n            window.requestAnimationFrame(loop);\n        };\n\n        this.loop = loop;\n\n        window.addEventListener('resize', resize);\n        window.addEventListener('scroll', scroll);\n        document.addEventListener('mousemove', mousemove, false);\n        if (this.canvas.hasAttribute('controls')) {\n            this.canvas.addEventListener('click', click);\n            this.canvas.addEventListener('mouseover', mouseover);\n            this.canvas.addEventListener('mouseout', mouseout);\n            if (!this.canvas.hasAttribute('data-autoplay')) {\n                this.pause();\n            }\n        }\n\n        this.removeListeners = () => {\n            window.removeEventListener('resize', resize);\n            window.removeEventListener('scroll', scroll);\n            document.removeEventListener('mousemove', mousemove);\n            if (this.canvas.hasAttribute('controls')) {\n                this.canvas.removeEventListener('click', click);\n                this.canvas.removeEventListener('mouseover', mouseover);\n                this.canvas.removeEventListener('mouseout', mouseout);\n            }\n        }\n    }\n\n    load(\n        fragmentString?: string,\n        vertexString?: string\n    ): void {\n        if (vertexString) {\n            this.vertexString = vertexString;\n        }\n        if (fragmentString) {\n            this.fragmentString = fragmentString;\n        }\n        const gl = this.gl;\n        const vertexShader = Context.createShader(gl, this.vertexString, gl.VERTEX_SHADER);\n        let fragmentShader = Context.createShader(gl, this.fragmentString, gl.FRAGMENT_SHADER);\n        // If Fragment shader fails load a empty one to sign the error\n        if (!fragmentShader) {\n            fragmentShader = Context.createShader(gl, `void main(){\n\t\t\t\tgl_FragColor = vec4(1.0);\n\t\t\t}`, gl.FRAGMENT_SHADER);\n            this.valid = false;\n        } else {\n            this.valid = true;\n        }\n        // Create and use program\n        const program = Context.createProgram(gl, [vertexShader, fragmentShader]); //, [0,1],['a_texcoord','a_position']);\n        gl.useProgram(program);\n        // Delete shaders\n        // gl.detachShader(program, vertexShader);\n        // gl.detachShader(program, fragmentShader);\n        gl.deleteShader(vertexShader);\n        gl.deleteShader(fragmentShader);\n        this.program = program;\n        if (this.valid) {\n            this.buffers = Buffers.getBuffers(gl, this.fragmentString, this.vertexString);\n            this.vertexBuffers = Context.createVertexBuffers(gl, program);\n            this.createUniforms();\n            // this.getBuffers(this.fragmentString);\n        }\n        // Trigger event\n        this.trigger('load', this);\n        // this.render();\n    }\n\n    test(\n        fragmentString?: string,\n        vertexString?: string\n    ): Promise<any> {\n        return new Promise((resolve, reject) => {\n            // Thanks to @thespite for the help here\n            // https://www.khronos.org/registry/webgl/extensions/EXT_disjoint_timer_query/\n            const vertex = this.vertexString;\n            const fragment = this.fragmentString;\n            const paused = this.timer.paused;\n            const extension = this.gl.getExtension('EXT_disjoint_timer_query');\n            const query = extension.createQueryEXT();\n            let wasValid = this.valid;\n            if (fragmentString || vertexString) {\n                this.load(fragmentString, vertexString);\n                wasValid = this.valid;\n                this.render();\n            }\n            this.timer.paused = true;\n            extension.beginQueryEXT(extension.TIME_ELAPSED_EXT, query);\n            this.render();\n            extension.endQueryEXT(extension.TIME_ELAPSED_EXT);\n            const waitForTest = () => {\n                this.render();\n                const available = extension.getQueryObjectEXT(query, extension.QUERY_RESULT_AVAILABLE_EXT);\n                const disjoint = this.gl.getParameter(extension.GPU_DISJOINT_EXT);\n                if (available && !disjoint) {\n                    const result = {\n                        wasValid: wasValid,\n                        fragment: fragmentString || this.fragmentString,\n                        vertex: vertexString || this.vertexString,\n                        timeElapsedMs: extension.getQueryObjectEXT(query, extension.QUERY_RESULT_EXT) / 1000000.0\n                    };\n                    this.timer.paused = paused;\n                    if (fragmentString || vertexString) {\n                        this.load(fragment, vertex);\n                    }\n                    resolve(result);\n                } else {\n                    window.requestAnimationFrame(waitForTest);\n                }\n            }\n            waitForTest();\n        });\n    }\n\n    destroy(): void {\n        this.removeListeners();\n        this.animated = false;\n        this.valid = false;\n        const gl = this.gl;\n        gl.useProgram(null);\n        gl.deleteProgram(this.program);\n        // this.buffers.forEach((buffer: IOBuffer) => buffer.destroy(gl));\n        for (const key in this.buffers.values) {\n            const buffer: IOBuffer = this.buffers.values[key];\n            buffer.destroy(gl);\n        }\n        for (const key in this.textures.values) {\n            const texture: Texture = this.textures.values[key];\n            texture.destroy(gl);\n        }\n        this.buffers = null;\n        this.textures = null;\n        this.uniforms = null;\n        this.program = null;\n        this.gl = null;\n        GlslCanvas.items.splice(GlslCanvas.items.indexOf(this), 1);\n    }\n\n    setUniform(key: string, ...values: any[]): void {\n        const uniform: Uniform | Uniform[] = Uniforms.parseUniform(key, ...values);\n        if (Array.isArray(uniform)) {\n            uniform.forEach((x) => this.loadTexture(x.key, x.values[0]));\n        } else if (uniform) {\n            switch (uniform.type) {\n                case UniformType.Sampler2D:\n                    this.loadTexture(key, values[0]);\n                    break;\n                default:\n                    this.uniforms.set(key, uniform);\n            }\n        }\n    }\n\n    setUniforms(values: IUniformOption): void {\n        for (const key in values) {\n            const value = values[key];\n            this.setUniform(key, ...value);\n        }\n    }\n\n    pause(): void {\n        if (this.valid) {\n            this.timer.pause();\n            this.canvas.classList.add('paused');\n            this.trigger('pause');\n        }\n    }\n\n    play(): void {\n        if (this.valid) {\n            this.timer.play();\n            this.canvas.classList.remove('paused');\n            this.trigger('play');\n        }\n    }\n\n    toggle(): void {\n        if (this.valid) {\n            if (this.timer.paused) {\n                this.play();\n            } else {\n                this.pause();\n            }\n        }\n    }\n\n    isVisible(): boolean {\n        const rect = this.rect;\n        return (rect.top + rect.height) > 0 && rect.top < (window.innerHeight || document.documentElement.clientHeight);\n    }\n\n    isAnimated(): boolean {\n        return (this.animated || this.textures.animated) && !this.timer.paused;\n    }\n\n    isDirty(): boolean {\n        return this.dirty || this.uniforms.dirty || this.textures.dirty;\n        // [].slice.call(this.textures.values()).reduce((p, texture) => p || texture.dirty, false);\n        // this.textures.dirty;\n    }\n\n    // check size change at start of requestFrame\n    sizeDidChanged(): boolean {\n        const gl = this.gl;\n        const rect = this.rect;\n        const W = rect.width,\n            H = rect.height;\n        if (this.width !== W ||\n            this.height !== H) {\n            this.width = W;\n            this.height = H;\n            // Lookup the size the browser is displaying the canvas in CSS pixels\n            // and compute a size needed to make our drawingbuffer match it in\n            // device pixels.\n            const BW = Math.floor(W * this.pixelRatio);\n            const BH = Math.floor(H * this.pixelRatio);\n            // Check if the canvas is not the same size.\n            if (gl.canvas.width !== BW ||\n                gl.canvas.height !== BH) {\n                // Make the canvas the same size\n                gl.canvas.width = BW;\n                gl.canvas.height = BH;\n                // Set the viewport to match\n                // gl.viewport(0, 0, BW, BH);\n            }\n            /*\n            this.buffers.forEach((buffer: IOBuffer) => {\n                buffer.resize(gl, BW, BH);\n            });            \n            */\n            for (const key in this.buffers.values) {\n                const buffer: IOBuffer = this.buffers.values[key];\n                buffer.resize(gl, BW, BH);\n            }\n            // gl.useProgram(this.program);\n            return true;\n        } else {\n            return false;\n        }\n    }\n\n    checkRender(): void {\n        if (this.isVisible() && (this.sizeDidChanged() || this.isAnimated() || this.isDirty())) {\n            this.render();\n            this.canvas.classList.add('playing');\n        } else {\n            this.canvas.classList.remove('playing');\n        }\n    }\n\n    createUniforms(): void {\n        const gl = this.gl;\n        const fragmentString = this.fragmentString;\n        const BW = gl.drawingBufferWidth;\n        const BH = gl.drawingBufferHeight;\n        const timer = this.timer = new GlslCanvasTimer();\n        const hasDelta = (fragmentString.match(/u_delta/g) || []).length > 1;\n        const hasTime = (fragmentString.match(/u_time/g) || []).length > 1;\n        const hasDate = (fragmentString.match(/u_date/g) || []).length > 1;\n        const hasMouse = (fragmentString.match(/u_mouse/g) || []).length > 1;\n        const hasTextures = this.parseTextures(fragmentString);\n        this.animated = hasTime || hasDate || hasMouse;\n        if (this.animated) {\n            this.canvas.classList.add('animated');\n        } else {\n            this.canvas.classList.remove('animated');\n        }\n        this.uniforms.create(UniformMethod.Uniform2f, UniformType.FloatVec2, 'u_resolution', BW, BH);\n        if (hasDelta) {\n            this.uniforms.create(UniformMethod.Uniform1f, UniformType.Float, 'u_delta', timer.delta);\n        }\n        if (hasTime) {\n            this.uniforms.create(UniformMethod.Uniform1f, UniformType.Float, 'u_time', timer.current);\n        }\n        if (hasDate) {\n            const date = new Date();\n            this.uniforms.create(UniformMethod.Uniform4f, UniformType.Float, 'u_date', date.getFullYear(), date.getMonth(), date.getDate(), date.getHours() * 3600 + date.getMinutes() * 60 + date.getSeconds() + date.getMilliseconds() * 0.001);\n        }\n        if (hasMouse) {\n            this.uniforms.create(UniformMethod.Uniform2f, UniformType.FloatVec2, 'u_mouse', 0, 0);\n        }\n        for (const key in this.buffers.values) {\n            const buffer: IOBuffer = this.buffers.values[key];\n            this.uniforms.create(UniformMethod.Uniform1i, UniformType.Sampler2D, buffer.key, buffer.input.index);\n        }\n        /*\n        this.buffers.forEach((buffer: IOBuffer) => {\n            this.uniforms.create(UniformMethod.Uniform1i, UniformType.Sampler2D, buffer.key, buffer.input.index);\n        });\n        */\n        if (hasTextures) {\n            this.textureList.forEach(x => {\n                this.loadTexture(x.key, x.url);\n            });\n        }\n        /*\n        while (this.textureList.length > 0) {\n            const x = this.textureList.shift();\n            this.loadTexture(x.key, x.url);\n        }\n        */\n    }\n\n    parseTextures(fragmentString: string): boolean {\n        const regexp = /uniform\\s*sampler2D\\s*([\\w]*);(\\s*\\/\\/\\s*([\\w|\\:\\/\\/|\\.|\\-|\\_]*)|\\s*)/gm;\n        let matches;\n        while ((matches = regexp.exec(fragmentString)) !== null) {\n            const key = matches[1];\n            if (matches[3]) {\n                const ext = matches[3].split('.').pop().toLowerCase();\n                const url = matches[3];\n                if (url && TextureExtensions.indexOf(ext) !== -1) {\n                    this.textureList.push({ key, url });\n                }\n            } else if (!this.buffers.has(key)) {\n                // create empty texture\n                this.textureList.push({ key, url: null });\n            }\n        }\n        if (this.canvas.hasAttribute('data-textures')) {\n            const urls = this.canvas.getAttribute('data-textures').split(',');\n            urls.forEach((url: string, i: number) => {\n                const key = 'u_tex' + i;\n                this.textureList.push({ key, url });\n            });\n        }\n        return this.textureList.length > 0;\n    }\n\n    loadTexture(\n        key: string,\n        urlElementOrData: string | HTMLCanvasElement | HTMLImageElement | HTMLVideoElement | Element | TextureData\n    ): Promise<Texture> {\n        if (this.valid) {\n            return this.textures.createOrUpdate(this.gl, key, urlElementOrData, this.buffers.count).then(texture => {\n                const index = texture.index;\n                const uniform = this.uniforms.createTexture(key, index);\n                uniform.texture = texture;\n                const keyResolution = key.indexOf('[') !== -1 ? key.replace('[', 'Resolution[') : key + 'Resolution';\n                const uniformResolution = this.uniforms.create(UniformMethod.Uniform2f, UniformType.FloatVec2, keyResolution, texture.width, texture.height);\n                // console.log('loadTexture', key, url, index, texture.width, texture.height);\n                return texture;\n            });\n        } else {\n            this.textureList.push({ key, url: urlElementOrData });\n        }\n    }\n\n    updateUniforms(): void {\n        const gl = this.gl;\n        const BW = gl.drawingBufferWidth;\n        const BH = gl.drawingBufferHeight;\n        const timer = this.timer.next();\n        this.uniforms.update(UniformMethod.Uniform2f, UniformType.FloatVec2, 'u_resolution', BW, BH);\n        if (this.uniforms.has('u_delta')) {\n            this.uniforms.update(UniformMethod.Uniform1f, UniformType.Float, 'u_delta', timer.delta);\n        }\n        if (this.uniforms.has('u_time')) {\n            this.uniforms.update(UniformMethod.Uniform1f, UniformType.Float, 'u_time', timer.current);\n        }\n        if (this.uniforms.has('u_date')) {\n            const date = new Date();\n            this.uniforms.update(UniformMethod.Uniform4f, UniformType.Float, 'u_date', date.getFullYear(), date.getMonth(), date.getDate(), date.getHours() * 3600 + date.getMinutes() * 60 + date.getSeconds() + date.getMilliseconds() * 0.001);\n        }\n        if (this.uniforms.has('u_mouse')) {\n            const rect = this.rect;\n            const mouse = this.mouse;\n            if (mouse.x >= rect.left && mouse.x <= rect.right &&\n                mouse.y >= rect.top && mouse.y <= rect.bottom) {\n                const MX = (mouse.x - rect.left) * this.pixelRatio;\n                const MY = (this.canvas.height - (mouse.y - rect.top) * this.pixelRatio);\n                this.uniforms.update(UniformMethod.Uniform2f, UniformType.FloatVec2, 'u_mouse', MX, MY);\n            }\n        }\n        for (const key in this.buffers.values) {\n            const buffer: IOBuffer = this.buffers.values[key];\n            this.uniforms.update(UniformMethod.Uniform1i, UniformType.Sampler2D, buffer.key, buffer.input.index);\n        }\n        /*\n        this.buffers.forEach((buffer: IOBuffer) => {\n            this.uniforms.update(UniformMethod.Uniform1i, UniformType.Sampler2D, buffer.key, buffer.input.index);\n        });\n        */\n        for (const key in this.textures.values) {\n            const texture: Texture = this.textures.values[key];\n            texture.tryUpdate(gl);\n            // console.log(texture.key, texture.index);\n            this.uniforms.update(UniformMethod.Uniform1i, UniformType.Sampler2D, texture.key, texture.index);\n        }\n        /*\n        this.textures.forEach((texture: Texture) => {\n            texture.tryUpdate(gl);\n            // console.log(texture.key, texture.index);\n            this.uniforms.update(UniformMethod.Uniform1i, UniformType.Sampler2D, texture.key, texture.index);\n        });\n        */\n    }\n\n    render(): void {\n        const gl = this.gl;\n        const BW = gl.drawingBufferWidth;\n        const BH = gl.drawingBufferHeight;\n        this.updateUniforms();\n        /*\n        this.buffers.forEach((buffer: IOBuffer) => {\n            this.uniforms.apply(gl, buffer.program);\n            buffer.render(gl, BW, BH);\n        });\n        */\n        for (const key in this.buffers.values) {\n            const buffer: IOBuffer = this.buffers.values[key];\n            this.uniforms.apply(gl, buffer.program);\n            buffer.render(gl, BW, BH);\n        }\n        gl.useProgram(this.program);\n        this.uniforms.apply(gl, this.program);\n        gl.viewport(0, 0, BW, BH);\n        gl.bindFramebuffer(gl.FRAMEBUFFER, null);\n        gl.drawArrays(gl.TRIANGLES, 0, 6);\n        this.uniforms.clean();\n        this.textures.clean();\n        this.dirty = false;\n        this.trigger('render', this);\n    }\n\n}\n\n(<any>window).GlslCanvas = GlslCanvas;\n\ndocument.addEventListener(\"DOMContentLoaded\", GlslCanvas.loadAll);"],"file":"glsl-canvas.js"}