{"version":3,"names":[],"mappings":"","sources":["src/glsl-canvas/glsl-canvas.ts"],"sourcesContent":["// import '@babel/polyfill';\nimport 'promise-polyfill';\nimport Buffers, { IOBuffer } from './buffers';\nimport Common from './common';\nimport Context, { ContextDefaultFragment, ContextDefaultVertex, ContextOptions, ContextVertexBuffers } from './context';\nimport Subscriber from './subscriber';\nimport Textures, { Texture, TextureData, TextureExtensions, TextureInput, TextureOptions } from './textures';\nimport Uniforms, { IUniformOption, Uniform, UniformMethod, UniformType } from './uniforms';\n\nexport interface IPoint {\n\tx: number,\n\ty: number,\n}\n\nexport class GlslCanvasOptions extends ContextOptions {\n\tvertexString?: string;\n\tfragmentString?: string;\n\tbackgroundColor?: string;\n\tworkpath?: string;\n\tonError?: Function;\n}\n\nexport class GlslCanvasTimer {\n\n\tstart: number;\n\tprevious: number;\n\tdelay: number = 0.0;\n\tcurrent: number = 0.0;\n\tdelta: number = 0.0;\n\tpaused: boolean = false;\n\n\tconstructor() {\n\t\tthis.start = this.previous = this.now();\n\t}\n\n\tnow() {\n\t\treturn performance.now();\n\t}\n\n\tplay() {\n\t\tif (this.previous) {\n\t\t\tconst now = this.now();\n\t\t\tthis.delay += (now - this.previous);\n\t\t\tthis.previous = now;\n\t\t}\n\t\t// console.log(this.delay);\n\t\tthis.paused = false;\n\t}\n\n\tpause() {\n\t\tthis.paused = true;\n\t}\n\n\tnext(): GlslCanvasTimer {\n\t\tconst now = this.now();\n\t\tthis.delta = now - this.previous;\n\t\tthis.current = now - this.start - this.delay;\n\t\tthis.previous = now;\n\t\treturn this;\n\t}\n\n}\n\nexport default class GlslCanvas extends Subscriber {\n\n\toptions: GlslCanvasOptions;\n\tcanvas: HTMLCanvasElement;\n\tgl: WebGLRenderingContext;\n\tprogram: WebGLProgram;\n\ttimer: GlslCanvasTimer;\n\tvertexBuffers: ContextVertexBuffers;\n\trect: ClientRect | DOMRect;\n\tmouse: IPoint = { x: 0, y: 0 };\n\tuniforms: Uniforms = new Uniforms();\n\tbuffers: Buffers = new Buffers();\n\ttextures: Textures = new Textures();\n\ttextureList: TextureInput[] = [];\n\n\tvertexString: string;\n\tfragmentString: string;\n\twidth: number;\n\theight: number;\n\tdevicePixelRatio: number;\n\n\tvalid: boolean = false;\n\tanimated: boolean = false;\n\tdirty: boolean = true;\n\tvisible: boolean = false;\n\n\tloop: Function;\n\tprivate removeListeners_: Function = () => { };\n\n\tconstructor(\n\t\tcanvas: HTMLCanvasElement,\n\t\toptions: GlslCanvasOptions = {\n\t\t\t// alpha: true,\n\t\t\t// antialias: true,\n\t\t\t// premultipliedAlpha: true\n\t\t}\n\t) {\n\t\tsuper();\n\t\tif (!canvas) {\n\t\t\treturn;\n\t\t}\n\t\tthis.options = options;\n\t\tthis.canvas = canvas;\n\t\tthis.width = 0; // canvas.clientWidth;\n\t\tthis.height = 0; // canvas.clientHeight;\n\t\tthis.rect = canvas.getBoundingClientRect();\n\t\tthis.vertexString = options.vertexString || ContextDefaultVertex;\n\t\tthis.fragmentString = options.fragmentString || ContextDefaultFragment;\n\t\tconst gl = Context.tryGetContext(canvas, options, options.onError);\n\t\tif (!gl) {\n\t\t\treturn;\n\t\t}\n\t\tthis.gl = gl;\n\t\tthis.devicePixelRatio = window.devicePixelRatio || 1;\n\t\tcanvas.style.backgroundColor = options.backgroundColor || 'rgba(0,0,0,0)';\n\t\tthis.getShaders_().then(\n\t\t\t(success) => {\n\t\t\t\tthis.load();\n\t\t\t\tif (!this.program) {\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t\tthis.addListeners_();\n\t\t\t\tthis.loop();\n\t\t\t},\n\t\t\t(error) => {\n\t\t\t\tconsole.log('GlslCanvas.getShaders_.error', error);\n\t\t\t});\n\t\tGlslCanvas.items.push(this);\n\t}\n\n\tstatic items: GlslCanvas[] = [];\n\n\tstatic version(): string {\n\t\treturn '0.2.0';\n\t}\n\n\tstatic of(canvas: HTMLCanvasElement): GlslCanvas {\n\t\treturn GlslCanvas.items.find(x => x.canvas === canvas) || new GlslCanvas(canvas);\n\t}\n\n\tstatic loadAll(): GlslCanvas[] {\n\t\tconst canvases: HTMLCanvasElement[] = <HTMLCanvasElement[]>[].slice.call(document.getElementsByClassName('glsl-canvas')).filter((x: HTMLElement) => x instanceof HTMLCanvasElement);\n\t\treturn canvases.map(x => GlslCanvas.of(x));\n\t}\n\n\tprivate getShaders_(): Promise<string[]> {\n\t\treturn new Promise((resolve, reject) => {\n\t\t\tconst canvas = this.canvas;\n\t\t\tconst urls: any = {};\n\t\t\tif (canvas.hasAttribute('data-vertex-url')) {\n\t\t\t\turls.vertex = canvas.getAttribute('data-vertex-url');\n\t\t\t}\n\t\t\tif (canvas.hasAttribute('data-fragment-url')) {\n\t\t\t\turls.fragment = canvas.getAttribute('data-fragment-url');\n\t\t\t}\n\t\t\tif (canvas.hasAttribute('data-vertex')) {\n\t\t\t\tthis.vertexString = canvas.getAttribute('data-vertex');\n\t\t\t}\n\t\t\tif (canvas.hasAttribute('data-fragment')) {\n\t\t\t\tthis.fragmentString = canvas.getAttribute('data-fragment');\n\t\t\t}\n\t\t\tif (Object.keys(urls).length) {\n\t\t\t\tPromise.all(Object.keys(urls).map((key, i) => {\n\t\t\t\t\tconst url: string = urls[key];\n\t\t\t\t\treturn Common.fetch(url)\n\t\t\t\t\t\t// .then((response) => response.text())\n\t\t\t\t\t\t.then((body) => {\n\t\t\t\t\t\t\tif (key === 'vertex') {\n\t\t\t\t\t\t\t\treturn this.vertexString = body;\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\treturn this.fragmentString = body;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t})\n\t\t\t\t}\n\t\t\t\t)).then(shaders => {\n\t\t\t\t\tresolve([this.vertexString, this.fragmentString]);\n\t\t\t\t});\n\t\t\t} else {\n\t\t\t\tresolve([this.vertexString, this.fragmentString]);\n\t\t\t}\n\t\t});\n\t}\n\n\tprivate addListeners_(): void {\n        /*\n        const resize = (e: Event) => {\n            this.rect = this.canvas.getBoundingClientRect();\n            this.trigger('resize', e);\n        };\n        */\n\n\t\tconst scroll = (e: Event) => {\n\t\t\tthis.rect = this.canvas.getBoundingClientRect();\n\t\t};\n\n\t\tconst click = (e: MouseEvent) => {\n\t\t\tthis.toggle();\n\t\t\tthis.trigger('click', e);\n\t\t};\n\n\t\tconst move = (mx: number, my: number) => {\n\t\t\tconst rect = this.rect, gap = 20;\n\t\t\tconst x = Math.max(-gap, Math.min(rect.width + gap, (mx - rect.left) * this.devicePixelRatio));\n\t\t\tconst y = Math.max(-gap, Math.min(rect.height + gap, (this.canvas.height - (my - rect.top) * this.devicePixelRatio)));\n\t\t\tif (x !== this.mouse.x ||\n\t\t\t\ty !== this.mouse.y) {\n\t\t\t\tthis.mouse.x = x;\n\t\t\t\tthis.mouse.y = y;\n\t\t\t\tthis.trigger('move', this.mouse);\n\t\t\t}\n\t\t};\n\n\t\tconst mousemove = (e: MouseEvent) => {\n\t\t\tmove(e.clientX || e.pageX, e.clientY || e.pageY);\n\t\t};\n\n\t\tconst mouseover = (e: MouseEvent) => {\n\t\t\tthis.play();\n\t\t\tthis.trigger('over', e);\n\t\t};\n\n\t\tconst mouseout = (e: MouseEvent) => {\n\t\t\tthis.pause();\n\t\t\tthis.trigger('out', e);\n\t\t};\n\n\t\tconst touchmove = (e: TouchEvent) => {\n\t\t\tconst touch = [].slice.call(e.touches).reduce((p: IPoint, touch: Touch) => {\n\t\t\t\tp = p || { x: 0, y: 0 };\n\t\t\t\tp.x += touch.clientX;\n\t\t\t\tp.y += touch.clientY;\n\t\t\t\treturn p;\n\t\t\t}, null);\n\t\t\tif (touch) {\n\t\t\t\tmove(touch.x / e.touches.length, touch.y / e.touches.length);\n\t\t\t}\n\t\t};\n\n\t\tconst touchend = (e: TouchEvent) => {\n\t\t\tthis.pause();\n\t\t\tthis.trigger('out', e);\n\t\t\tdocument.removeEventListener('touchend', touchend);\n\t\t};\n\n\t\tconst touchstart = (e: TouchEvent) => {\n\t\t\tthis.play();\n\t\t\tthis.trigger('over', e);\n\t\t\tdocument.addEventListener('touchend', touchend);\n\t\t\tdocument.removeEventListener('mousemove', mousemove);\n\t\t\tif (this.canvas.hasAttribute('controls')) {\n\t\t\t\tthis.canvas.removeEventListener('mouseover', mouseover);\n\t\t\t\tthis.canvas.removeEventListener('mouseout', mouseout);\n\t\t\t}\n\t\t};\n\n\t\tconst loop: FrameRequestCallback = (time: number) => {\n\t\t\tthis.checkRender();\n\t\t\twindow.requestAnimationFrame(loop);\n\t\t};\n\n\t\tthis.loop = loop;\n\n\t\t// window.addEventListener('resize', resize);\n\t\twindow.addEventListener('scroll', scroll);\n\t\tdocument.addEventListener('mousemove', mousemove, false);\n\t\tdocument.addEventListener('touchmove', touchmove);\n\t\tif (this.canvas.hasAttribute('controls')) {\n\t\t\tthis.canvas.addEventListener('click', click);\n\t\t\tthis.canvas.addEventListener('mouseover', mouseover);\n\t\t\tthis.canvas.addEventListener('mouseout', mouseout);\n\t\t\tthis.canvas.addEventListener('touchstart', touchstart);\n\t\t\tif (!this.canvas.hasAttribute('data-autoplay')) {\n\t\t\t\tthis.pause();\n\t\t\t}\n\t\t}\n\n\t\tthis.removeListeners_ = () => {\n\t\t\t// window.removeEventListener('resize', resize);\n\t\t\twindow.removeEventListener('scroll', scroll);\n\t\t\tdocument.removeEventListener('mousemove', mousemove);\n\t\t\tdocument.removeEventListener('touchmove', touchmove);\n\t\t\tif (this.canvas.hasAttribute('controls')) {\n\t\t\t\tthis.canvas.removeEventListener('click', click);\n\t\t\t\tthis.canvas.removeEventListener('mouseover', mouseover);\n\t\t\t\tthis.canvas.removeEventListener('mouseout', mouseout);\n\t\t\t\tthis.canvas.removeEventListener('touchstart', touchstart);\n\t\t\t}\n\t\t}\n\t}\n\n\tprivate setUniform_(\n\t\tkey: string,\n\t\tvalues: any[],\n\t\toptions: TextureOptions = {},\n\t\ttype: UniformType = null\n\t): void {\n\t\tconst uniform: Uniform | Uniform[] = Uniforms.parseUniform(key, values, type);\n\t\tif (Array.isArray(uniform)) {\n\t\t\tif (Uniforms.isArrayOfSampler2D(uniform)) {\n\t\t\t\tuniform.forEach((x) => this.loadTexture(x.key, x.values[0], options));\n\t\t\t} else {\n\t\t\t\tuniform.forEach((x) => this.uniforms.set(x.key, x.values[0]));\n\t\t\t}\n\t\t} else if (uniform) {\n\t\t\tswitch (uniform.type) {\n\t\t\t\tcase UniformType.Sampler2D:\n\t\t\t\t\tthis.loadTexture(key, values[0], options);\n\t\t\t\t\tbreak;\n\t\t\t\tdefault:\n\t\t\t\t\tthis.uniforms.set(key, uniform);\n\t\t\t}\n\t\t}\n\t}\n\n\tprivate parseTextures_(fragmentString: string): boolean {\n\t\tconst regexp = /uniform\\s*sampler2D\\s*([\\w]*);(\\s*\\/\\/\\s*([\\w|\\:\\/\\/|\\.|\\-|\\_]*)|\\s*)/gm;\n\t\tlet matches;\n\t\twhile ((matches = regexp.exec(fragmentString)) !== null) {\n\t\t\tconst key = matches[1];\n\t\t\tif (matches[3]) {\n\t\t\t\tconst ext = matches[3].split('.').pop().toLowerCase();\n\t\t\t\tconst url = matches[3];\n\t\t\t\tif (url && TextureExtensions.indexOf(ext) !== -1) {\n\t\t\t\t\tthis.textureList.push({ key, url });\n\t\t\t\t}\n\t\t\t} else if (!this.buffers.has(key)) {\n\t\t\t\t// create empty texture\n\t\t\t\tthis.textureList.push({ key, url: null });\n\t\t\t}\n\t\t}\n\t\tif (this.canvas.hasAttribute('data-textures')) {\n\t\t\tconst urls = this.canvas.getAttribute('data-textures').split(',');\n\t\t\turls.forEach((url: string, i: number) => {\n\t\t\t\tconst key = 'u_texture' + i;\n\t\t\t\tthis.textureList.push({ key, url });\n\t\t\t});\n\t\t}\n\t\treturn this.textureList.length > 0;\n\t}\n\n\tprivate createUniforms_(): void {\n\t\tconst gl = this.gl;\n\t\tconst fragmentString = this.fragmentString;\n\t\tconst BW = gl.drawingBufferWidth;\n\t\tconst BH = gl.drawingBufferHeight;\n\t\tconst timer = this.timer = new GlslCanvasTimer();\n\t\tconst hasDelta = (fragmentString.match(/u_delta/g) || []).length > 1;\n\t\tconst hasTime = (fragmentString.match(/u_time/g) || []).length > 1;\n\t\tconst hasDate = (fragmentString.match(/u_date/g) || []).length > 1;\n\t\tconst hasMouse = (fragmentString.match(/u_mouse/g) || []).length > 1;\n\t\tconst hasTextures = this.parseTextures_(fragmentString);\n\t\tthis.animated = hasTime || hasDate || hasMouse;\n\t\tif (this.animated) {\n\t\t\tthis.canvas.classList.add('animated');\n\t\t} else {\n\t\t\tthis.canvas.classList.remove('animated');\n\t\t}\n\t\tthis.uniforms.create(UniformMethod.Uniform2f, UniformType.Float, 'u_resolution', [BW, BH]);\n\t\tif (hasDelta) {\n\t\t\tthis.uniforms.create(UniformMethod.Uniform1f, UniformType.Float, 'u_delta', [timer.delta / 1000.0]);\n\t\t}\n\t\tif (hasTime) {\n\t\t\tthis.uniforms.create(UniformMethod.Uniform1f, UniformType.Float, 'u_time', [timer.current / 1000.0]);\n\t\t}\n\t\tif (hasDate) {\n\t\t\tconst date = new Date();\n\t\t\tthis.uniforms.create(UniformMethod.Uniform4f, UniformType.Float, 'u_date', [date.getFullYear(), date.getMonth(), date.getDate(), date.getHours() * 3600 + date.getMinutes() * 60 + date.getSeconds() + date.getMilliseconds() * 0.001]);\n\t\t}\n\t\tif (hasMouse) {\n\t\t\tthis.uniforms.create(UniformMethod.Uniform2f, UniformType.Float, 'u_mouse', [0, 0]);\n\t\t}\n\t\tfor (const key in this.buffers.values) {\n\t\t\tconst buffer: IOBuffer = this.buffers.values[key];\n\t\t\tthis.uniforms.create(UniformMethod.Uniform1i, UniformType.Sampler2D, buffer.key, [buffer.input.index]);\n\t\t}\n\t\tif (hasTextures) {\n\t\t\tthis.textureList.filter(x => x.url).forEach(x => {\n\t\t\t\tthis.setTexture(x.key, x.url, x.options);\n\t\t\t});\n\t\t\tthis.textureList = [];\n\t\t}\n\t}\n\n\tprivate updateUniforms_(): void {\n\t\tconst gl = this.gl;\n\t\tconst BW = gl.drawingBufferWidth;\n\t\tconst BH = gl.drawingBufferHeight;\n\t\tconst timer = this.timer.next();\n\t\tthis.uniforms.update(UniformMethod.Uniform2f, UniformType.Float, 'u_resolution', [BW, BH]);\n\t\tif (this.uniforms.has('u_delta')) {\n\t\t\tthis.uniforms.update(UniformMethod.Uniform1f, UniformType.Float, 'u_delta', [timer.delta / 1000.0]);\n\t\t}\n\t\tif (this.uniforms.has('u_time')) {\n\t\t\tthis.uniforms.update(UniformMethod.Uniform1f, UniformType.Float, 'u_time', [timer.current / 1000.0]);\n\t\t}\n\t\tif (this.uniforms.has('u_date')) {\n\t\t\tconst date = new Date();\n\t\t\tthis.uniforms.update(UniformMethod.Uniform4f, UniformType.Float, 'u_date', [date.getFullYear(), date.getMonth(), date.getDate(), date.getHours() * 3600 + date.getMinutes() * 60 + date.getSeconds() + date.getMilliseconds() * 0.001]);\n\t\t}\n\t\tif (this.uniforms.has('u_mouse')) {\n\t\t\tconst mouse = this.mouse;\n\t\t\tthis.uniforms.update(UniformMethod.Uniform2f, UniformType.Float, 'u_mouse', [mouse.x, mouse.y]);\n            /*\n            const rect = this.rect;\n            if (mouse.x >= rect.left && mouse.x <= rect.right &&\n                mouse.y >= rect.top && mouse.y <= rect.bottom) {\n                const MX = (mouse.x - rect.left) * this.devicePixelRatio;\n                const MY = (this.canvas.height - (mouse.y - rect.top) * this.devicePixelRatio);\n                this.uniforms.update(UniformMethod.Uniform2f, UniformType.Float, 'u_mouse', [MX, MY]);\n            }\n            */\n\t\t}\n\t\tfor (const key in this.buffers.values) {\n\t\t\tconst buffer: IOBuffer = this.buffers.values[key];\n\t\t\tthis.uniforms.update(UniformMethod.Uniform1i, UniformType.Sampler2D, buffer.key, [buffer.input.index]);\n\t\t}\n\t\tfor (const key in this.textures.values) {\n\t\t\tconst texture: Texture = this.textures.values[key];\n\t\t\ttexture.tryUpdate(gl);\n\t\t\tthis.uniforms.update(UniformMethod.Uniform1i, UniformType.Sampler2D, texture.key, [texture.index]);\n\t\t}\n\t}\n\n\tprivate isVisible_(): boolean {\n\t\tconst rect = this.rect;\n\t\treturn (rect.top + rect.height) > 0 && rect.top < (window.innerHeight || document.documentElement.clientHeight);\n\t}\n\n\tprivate isAnimated_(): boolean {\n\t\treturn (this.animated || this.textures.animated) && !this.timer.paused;\n\t}\n\n\tprivate isDirty_(): boolean {\n\t\treturn this.dirty || this.uniforms.dirty || this.textures.dirty;\n\t}\n\n\t// check size change at start of requestFrame\n\tprivate sizeDidChanged_(): boolean {\n\t\tconst gl = this.gl;\n\t\tconst W = Math.ceil(this.canvas.clientWidth),\n\t\t\tH = Math.ceil(this.canvas.clientHeight);\n\t\tif (this.width !== W ||\n\t\t\tthis.height !== H) {\n\t\t\tthis.width = W;\n\t\t\tthis.height = H;\n\t\t\t// Lookup the size the browser is displaying the canvas in CSS pixels\n\t\t\t// and compute a size needed to make our drawingbuffer match it in\n\t\t\t// device pixels.\n\t\t\tconst BW = Math.ceil(W * this.devicePixelRatio);\n\t\t\tconst BH = Math.ceil(H * this.devicePixelRatio);\n\t\t\tthis.canvas.width = BW;\n\t\t\tthis.canvas.height = BH;\n            /*\n            if (gl.canvas.width !== BW ||\n                gl.canvas.height !== BH) {\n                gl.canvas.width = BW;\n                gl.canvas.height = BH;\n                // Set the viewport to match\n                // gl.viewport(0, 0, BW, BH);\n            }\n            */\n\t\t\tfor (const key in this.buffers.values) {\n\t\t\t\tconst buffer: IOBuffer = this.buffers.values[key];\n\t\t\t\tbuffer.resize(gl, BW, BH);\n\t\t\t}\n\t\t\tthis.rect = this.canvas.getBoundingClientRect();\n\t\t\tthis.trigger('resize');\n\t\t\t// gl.useProgram(this.program);\n\t\t\treturn true;\n\t\t} else {\n\t\t\treturn false;\n\t\t}\n\t}\n\n\tload(\n\t\tfragmentString?: string,\n\t\tvertexString?: string\n\t): void {\n\t\tif (vertexString) {\n\t\t\tthis.vertexString = vertexString;\n\t\t}\n\t\tif (fragmentString) {\n\t\t\tthis.fragmentString = fragmentString;\n\t\t}\n\t\tconst gl = this.gl;\n\t\tlet vertexShader, fragmentShader;\n\t\ttry {\n\t\t\tvertexShader = Context.createShader(gl, this.vertexString, gl.VERTEX_SHADER);\n\t\t\tfragmentShader = Context.createShader(gl, this.fragmentString, gl.FRAGMENT_SHADER);\n\t\t\t// If Fragment shader fails load a empty one to sign the error\n\t\t\tif (!fragmentShader) {\n\t\t\t\tfragmentShader = Context.createShader(gl, ContextDefaultFragment, gl.FRAGMENT_SHADER);\n\t\t\t\tthis.valid = false;\n\t\t\t} else {\n\t\t\t\tthis.valid = true;\n\t\t\t}\n\t\t} catch (e) {\n\t\t\tthis.trigger('error', e);\n\t\t\treturn;\n\t\t}\n\t\t// Create and use program\n\t\tconst program = Context.createProgram(gl, [vertexShader, fragmentShader]); //, [0,1],['a_texcoord','a_position']);\n\t\tgl.useProgram(program);\n\t\t// Delete shaders\n\t\t// gl.detachShader(program, vertexShader);\n\t\t// gl.detachShader(program, fragmentShader);\n\t\tgl.deleteShader(vertexShader);\n\t\tgl.deleteShader(fragmentShader);\n\t\tthis.program = program;\n\t\tif (this.valid) {\n\t\t\tthis.buffers = Buffers.getBuffers(gl, this.fragmentString, this.vertexString);\n\t\t\tthis.vertexBuffers = Context.createVertexBuffers(gl, program);\n\t\t\tthis.createUniforms_();\n\t\t}\n\t\t// Trigger event\n\t\tthis.trigger('load', this);\n\t}\n\n\ttest(\n\t\tfragmentString?: string,\n\t\tvertexString?: string\n\t): Promise<any> {\n\t\treturn new Promise((resolve, reject) => {\n\t\t\tconst vertex = this.vertexString;\n\t\t\tconst fragment = this.fragmentString;\n\t\t\tconst paused = this.timer.paused;\n\t\t\t// Thanks to @thespite for the help here\n\t\t\t// https://www.khronos.org/registry/webgl/extensions/EXT_disjoint_timer_query/\n\t\t\tconst extension = this.gl.getExtension('EXT_disjoint_timer_query');\n\t\t\tconst query = extension.createQueryEXT();\n\t\t\tlet wasValid = this.valid;\n\t\t\tif (fragmentString || vertexString) {\n\t\t\t\tthis.load(fragmentString, vertexString);\n\t\t\t\twasValid = this.valid;\n\t\t\t\tthis.render();\n\t\t\t}\n\t\t\tthis.timer.paused = true;\n\t\t\textension.beginQueryEXT(extension.TIME_ELAPSED_EXT, query);\n\t\t\tthis.render();\n\t\t\textension.endQueryEXT(extension.TIME_ELAPSED_EXT);\n\t\t\tconst waitForTest = () => {\n\t\t\t\tthis.render();\n\t\t\t\tconst available = extension.getQueryObjectEXT(query, extension.QUERY_RESULT_AVAILABLE_EXT);\n\t\t\t\tconst disjoint = this.gl.getParameter(extension.GPU_DISJOINT_EXT);\n\t\t\t\tif (available && !disjoint) {\n\t\t\t\t\tconst result = {\n\t\t\t\t\t\twasValid: wasValid,\n\t\t\t\t\t\tfragment: fragmentString || this.fragmentString,\n\t\t\t\t\t\tvertex: vertexString || this.vertexString,\n\t\t\t\t\t\ttimeElapsedMs: extension.getQueryObjectEXT(query, extension.QUERY_RESULT_EXT) / 1000000.0\n\t\t\t\t\t};\n\t\t\t\t\tthis.timer.paused = paused;\n\t\t\t\t\tif (fragmentString || vertexString) {\n\t\t\t\t\t\tthis.load(fragment, vertex);\n\t\t\t\t\t}\n\t\t\t\t\tresolve(result);\n\t\t\t\t} else {\n\t\t\t\t\twindow.requestAnimationFrame(waitForTest);\n\t\t\t\t}\n\t\t\t}\n\t\t\twaitForTest();\n\t\t});\n\t}\n\n\tdestroy(): void {\n\t\tthis.removeListeners_();\n\t\tthis.animated = false;\n\t\tthis.valid = false;\n\t\tconst gl = this.gl;\n\t\tgl.useProgram(null);\n\t\tgl.deleteProgram(this.program);\n\t\tfor (const key in this.buffers.values) {\n\t\t\tconst buffer: IOBuffer = this.buffers.values[key];\n\t\t\tbuffer.destroy(gl);\n\t\t}\n\t\tfor (const key in this.textures.values) {\n\t\t\tconst texture: Texture = this.textures.values[key];\n\t\t\ttexture.destroy(gl);\n\t\t}\n\t\tthis.buffers = null;\n\t\tthis.textures = null;\n\t\tthis.uniforms = null;\n\t\tthis.program = null;\n\t\tthis.gl = null;\n\t\tGlslCanvas.items.splice(GlslCanvas.items.indexOf(this), 1);\n\t}\n\n\tloadTexture(\n\t\tkey: string,\n\t\turlElementOrData: string | HTMLCanvasElement | HTMLImageElement | HTMLVideoElement | Element | TextureData,\n\t\toptions: TextureOptions = {}\n\t) {\n\t\tif (this.valid) {\n\t\t\t// console.log(key, urlElementOrData);\n\t\t\tthis.textures.createOrUpdate(this.gl, key, urlElementOrData, this.buffers.count, options, this.options.workpath).then(\n\t\t\t\ttexture => {\n\t\t\t\t\tconst index = texture.index;\n\t\t\t\t\tconst uniform = this.uniforms.createTexture(key, index);\n\t\t\t\t\tuniform.texture = texture;\n\t\t\t\t\tconst keyResolution = key.indexOf('[') !== -1 ? key.replace('[', 'Resolution[') : key + 'Resolution';\n\t\t\t\t\tconst uniformResolution = this.uniforms.create(UniformMethod.Uniform2f, UniformType.Float, keyResolution, [texture.width, texture.height]);\n\t\t\t\t\t// console.log('loadTexture', key, url, index, texture.width, texture.height);\n\t\t\t\t\treturn texture;\n\t\t\t\t},\n\t\t\t\terror => {\n\t\t\t\t\tconsole.log('GlslCanvas.loadTexture.error', error, key, urlElementOrData);\n\t\t\t\t});\n\t\t} else {\n\t\t\tthis.textureList.push({ key, url: urlElementOrData, options });\n\t\t}\n\t}\n\n\tsetTexture(\n\t\tkey: string,\n\t\turlElementOrData: string | HTMLCanvasElement | HTMLImageElement | HTMLVideoElement | Element | TextureData,\n\t\toptions: TextureOptions = {}\n\t): void {\n\t\treturn this.setUniform_(key, [urlElementOrData], options);\n\t}\n\n\tsetUniform(key: string, ...values: any[]): void {\n\t\treturn this.setUniform_(key, values);\n\t}\n\n\tsetUniformOfInt(key: string, values: any[]): void {\n\t\treturn this.setUniform_(key, values, null, UniformType.Int);\n\t}\n\n\tsetUniforms(values: IUniformOption): void {\n\t\tfor (const key in values) {\n\t\t\tthis.setUniform(key, values[key]);\n\t\t}\n\t}\n\n\tpause(): void {\n\t\tif (this.valid) {\n\t\t\tthis.timer.pause();\n\t\t\tthis.canvas.classList.add('paused');\n\t\t\tthis.trigger('pause');\n\t\t}\n\t}\n\n\tplay(): void {\n\t\tif (this.valid) {\n\t\t\tthis.timer.play();\n\t\t\tthis.canvas.classList.remove('paused');\n\t\t\tthis.trigger('play');\n\t\t}\n\t}\n\n\ttoggle(): void {\n\t\tif (this.valid) {\n\t\t\tif (this.timer.paused) {\n\t\t\t\tthis.play();\n\t\t\t} else {\n\t\t\t\tthis.pause();\n\t\t\t}\n\t\t}\n\t}\n\n\tcheckRender(): void {\n\t\tif (this.isVisible_() && (this.sizeDidChanged_() || this.isAnimated_() || this.isDirty_())) {\n\t\t\tthis.render();\n\t\t\tthis.canvas.classList.add('playing');\n\t\t} else {\n\t\t\tthis.canvas.classList.remove('playing');\n\t\t}\n\t}\n\n\trender(): void {\n\t\tconst gl = this.gl;\n\t\tconst BW = gl.drawingBufferWidth;\n\t\tconst BH = gl.drawingBufferHeight;\n\t\tthis.updateUniforms_();\n\t\tfor (const key in this.buffers.values) {\n\t\t\tconst buffer: IOBuffer = this.buffers.values[key];\n\t\t\tthis.uniforms.apply(gl, buffer.program);\n\t\t\tbuffer.render(gl, BW, BH);\n\t\t}\n\t\tgl.useProgram(this.program);\n\t\tthis.uniforms.apply(gl, this.program);\n\t\tgl.viewport(0, 0, BW, BH);\n\t\tgl.bindFramebuffer(gl.FRAMEBUFFER, null);\n\t\tgl.drawArrays(gl.TRIANGLES, 0, 6);\n\t\tthis.uniforms.clean();\n\t\tthis.textures.clean();\n\t\tthis.dirty = false;\n\t\tthis.trigger('render', this);\n\t}\n\n}\n\ndeclare global {\n\tinterface Window { GlslCanvas: any; }\n}\n\nwindow.GlslCanvas = window.GlslCanvas || GlslCanvas;\n// (<any>(window)).GlslCanvas = GlslCanvas;\n\nif (document) {\n\tdocument.addEventListener(\"DOMContentLoaded\", () => {\n\t\tGlslCanvas.loadAll();\n\t});\n}\n"],"file":"docs/js/glsl-canvas.js"}