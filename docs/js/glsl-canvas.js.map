{"version":3,"names":[],"mappings":"","sources":["src/glsl-canvas/glsl-canvas.ts"],"sourcesContent":["// import '@babel/polyfill';\nimport 'whatwg-fetch';\nimport Buffers from './buffers';\nimport Context, { ContextVertexBuffers } from './context';\nimport ListenerSubscriber from './listener.subscriber';\nimport Textures, { Texture, TextureExtensions } from './textures';\nimport Uniforms, { Uniform } from './uniforms';\n\nconst GlslCanvasDefaultVertex = `\n#ifdef GL_ES\nprecision mediump float;\n#endif\n\nattribute vec2 a_position;\nattribute vec2 a_texcoord;\n\nvarying vec2 v_texcoord;\n\nvoid main(){\n\tgl_Position = vec4(a_position, 0.0, 1.0);\n\tv_texcoord = a_texcoord;\n}\n`;\n\nconst GlslCanvasDefaultFragment = `\n#ifdef GL_ES\nprecision mediump float;\n#endif\n\nvarying vec2 v_texcoord;\n\nvoid main(){\n\tgl_FragColor = vec4(0.0);\n}\n`;\n\nexport interface ICanvasContextOptions {\n\tbackgroundColor?: string;\n\tvertexString?: string;\n\tfragmentString?: string;\n\talpha?: GLboolean;\n\tantialias?: GLboolean;\n\tdepth?: GLboolean;\n\tfailIfMajorPerformanceCaveat?: boolean;\n\tpowerPreference?: WebGLPowerPreference;\n\tpremultipliedAlpha?: GLboolean;\n\tpreserveDrawingBuffer?: GLboolean;\n\tstencil?: GLboolean;\n}\n\nexport interface IPoint {\n\tx: number,\n\ty: number,\n}\n\nexport class GlslCanvasOptions {\n\n}\n\nexport class GlslCanvasTimer {\n\tstart: number;\n\tprevious: number;\n\tdelay: number = 0.0;\n\tcurrent: number = 0.0;\n\tdelta: number = 0.0;\n\tpaused: boolean = false;\n\n\tconstructor() {\n\t\tthis.start = this.previous = performance.now() / 1000.0;\n\t}\n\n\tplay() {\n\t\tif (this.previous) {\n\t\t\tconst now = performance.now() / 1000.0;\n\t\t\tthis.delay += (now - this.previous);\n\t\t\tthis.previous = now;\n\t\t}\n\t\tconsole.log(this.delay);\n\t\tthis.paused = false;\n\t}\n\n\tpause() {\n\t\tthis.paused = true;\n\t}\n\n\tnext(): GlslCanvasTimer {\n\t\tconst now = performance.now() / 1000.0;\n\t\tthis.delta = now - this.previous;\n\t\tthis.current = now - this.start - this.delay;\n\t\tthis.previous = now;\n\t\treturn this;\n\t}\n\n}\n\nexport default class GlslCanvas extends ListenerSubscriber {\n\n\tcanvas: HTMLCanvasElement;\n\twidth: number;\n\theight: number;\n\ttimer: GlslCanvasTimer;\n\tdirty: boolean = true;\n\n\tanimated: boolean = false;\n\tnDelta: number = 0;\n\tnTime: number = 0;\n\tnDate: number = 0;\n\tnMouse: number = 0;\n\n\tpixelRatio: number;\n\tgl: WebGLRenderingContext;\n\tprogram: WebGLProgram;\n\ttextures: Textures = new Textures();\n\tbuffers: Buffers = new Buffers();\n\tuniforms: Uniforms = new Uniforms();\n\tvertexBuffers: ContextVertexBuffers;\n\trect: ClientRect | DOMRect;\n\tmouse: IPoint = { x: 0, y: 0 };\n\tvalid: boolean = false;\n\tvisible: boolean = false;\n\ttextureIndex: number = 0;\n\t// TEXTURE_COUNT:number = 0;\n\tvertexString: string;\n\tfragmentString: string;\n\tresize: Function;\n\tscroll: Function;\n\tmousemove: Function;\n\tclick: Function;\n\tloop: Function;\n\n\tconstructor(\n\t\tcanvas: HTMLCanvasElement,\n\t\tcontextOptions: ICanvasContextOptions = {},\n\t\toptions: any = {}\n\t) {\n\t\tsuper();\n\t\tif (!canvas) {\n\t\t\treturn;\n\t\t}\n\t\tthis.canvas = canvas;\n\t\tthis.width = canvas.clientWidth;\n\t\tthis.height = canvas.clientHeight;\n\t\tthis.rect = canvas.getBoundingClientRect();\n\t\tthis.vertexString = contextOptions.vertexString || GlslCanvasDefaultVertex;\n\t\tthis.fragmentString = contextOptions.fragmentString || GlslCanvasDefaultFragment;\n\t\tconst gl = Context.tryGetContext(canvas, contextOptions, options.onError);\n\t\tif (!gl) {\n\t\t\treturn;\n\t\t}\n\t\tthis.gl = gl;\n\t\tthis.pixelRatio = window.devicePixelRatio || 1;\n\t\tcanvas.style.backgroundColor = contextOptions.backgroundColor || 'rgba(0,0,0,0)';\n\t\tthis.getShaders().then(\n\t\t\t(success) => {\n\t\t\t\tthis.load();\n\t\t\t\tif (!this.program) {\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t\tthis.addListeners();\n\t\t\t\tthis.loop();\n\t\t\t\t// this.animated = false;\n\t\t\t},\n\t\t\t(error) => {\n\t\t\t\tconsole.log('error', error);\n\t\t\t});\n\t}\n\n\tstatic version(): string {\n\t\treturn '0.1.8';\n\t}\n\n\tstatic isDifferent(a: any, b: any): boolean {\n\t\tif (a && b) {\n\t\t\treturn a.toString() !== b.toString();\n\t\t}\n\t\treturn false;\n\t}\n\n\tgetShaders(): Promise<string[]> {\n\t\treturn new Promise((resolve, reject) => {\n\t\t\tconst canvas = this.canvas;\n\t\t\tconst urls = [];\n\t\t\tif (canvas.hasAttribute('data-vertex-url')) {\n\t\t\t\turls.push(canvas.getAttribute('data-vertex-url'));\n\t\t\t}\n\t\t\tif (canvas.hasAttribute('data-fragment-url')) {\n\t\t\t\turls.push(canvas.getAttribute('data-fragment-url'));\n\t\t\t}\n\t\t\tif (urls.length) {\n\t\t\t\tPromise.all(urls.map((url, i) =>\n\t\t\t\t\tfetch(url)\n\t\t\t\t\t\t.then((response) => response.text())\n\t\t\t\t\t\t.then((body) => {\n\t\t\t\t\t\t\tif (i === 0) {\n\t\t\t\t\t\t\t\treturn this.vertexString = body;\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\treturn this.fragmentString = body;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t})\n\t\t\t\t)).then(shaders => {\n\t\t\t\t\tresolve(shaders);\n\t\t\t\t});\n\t\t\t} else {\n\t\t\t\tif (canvas.hasAttribute('data-vertex')) {\n\t\t\t\t\tthis.vertexString = canvas.getAttribute('data-vertex');\n\t\t\t\t}\n\t\t\t\tif (canvas.hasAttribute('data-fragment')) {\n\t\t\t\t\tthis.fragmentString = canvas.getAttribute('data-fragment');\n\t\t\t\t}\n\t\t\t\tresolve([this.vertexString, this.fragmentString]);\n\t\t\t}\n\t\t});\n\t}\n\n\taddListeners(): void {\n\t\t// resize buffers on canvas resize\n\t\t// consider applying a throttle of 50 ms on canvas resize\n\t\t// to avoid requestAnimationFrame and Gl violations\n\t\tconst resize = (e: Event) => {\n\t\t\tthis.rect = this.canvas.getBoundingClientRect();\n\t\t};\n\n\t\tconst scroll = (e: Event) => {\n\t\t\tthis.rect = this.canvas.getBoundingClientRect();\n\t\t};\n\n\t\tconst mousemove = (e: MouseEvent) => {\n\t\t\tthis.mouse.x = e.clientX || e.pageX;\n\t\t\tthis.mouse.y = e.clientY || e.pageY;\n\t\t};\n\n\t\tconst click = (e: MouseEvent) => {\n\t\t\tif (this.timer.paused) {\n\t\t\t\tthis.play();\n\t\t\t} else {\n\t\t\t\tthis.pause();\n\t\t\t}\n\t\t};\n\n\t\tconst loop: FrameRequestCallback = (time: number) => {\n\t\t\tthis.checkRender();\n\t\t\twindow.requestAnimationFrame(loop);\n\t\t};\n\n\t\tthis.resize = resize;\n\t\tthis.scroll = scroll;\n\t\tthis.mousemove = mousemove;\n\t\tthis.click = click;\n\t\tthis.loop = loop;\n\n\t\twindow.addEventListener('resize', resize);\n\t\twindow.addEventListener('scroll', scroll);\n\t\tdocument.addEventListener('mousemove', mousemove, false);\n\t\tif (this.canvas.hasAttribute('controls')) {\n\t\t\tthis.canvas.addEventListener('click', click);\n\t\t\tif (!this.canvas.hasAttribute('autoplay')) {\n\t\t\t\tthis.pause();\n\t\t\t}\n\t\t}\n\t}\n\n\tload(\n\t\tfragmentString?: string,\n\t\tvertexString?: string\n\t): void {\n\t\tif (vertexString) {\n\t\t\tthis.vertexString = vertexString;\n\t\t}\n\t\tif (fragmentString) {\n\t\t\tthis.fragmentString = fragmentString;\n\t\t}\n\t\tconst gl = this.gl;\n\t\tconst vertexShader = Context.createShader(gl, this.vertexString, gl.VERTEX_SHADER);\n\t\tlet fragmentShader = Context.createShader(gl, this.fragmentString, gl.FRAGMENT_SHADER);\n\t\t// If Fragment shader fails load a empty one to sign the error\n\t\tif (!fragmentShader) {\n\t\t\tfragmentShader = Context.createShader(gl, `void main(){\n\t\t\t\tgl_FragColor = vec4(1.0);\n\t\t\t}`, gl.FRAGMENT_SHADER);\n\t\t\tthis.valid = false;\n\t\t} else {\n\t\t\tthis.valid = true;\n\t\t}\n\t\t// Create and use program\n\t\tconst program = Context.createProgram(gl, [vertexShader, fragmentShader]); //, [0,1],['a_texcoord','a_position']);\n\t\tgl.useProgram(program);\n\t\t// Delete shaders\n\t\t// gl.detachShader(program, vertexShader);\n\t\t// gl.detachShader(program, fragmentShader);\n\t\tgl.deleteShader(vertexShader);\n\t\tgl.deleteShader(fragmentShader);\n\t\tthis.program = program;\n\t\tif (this.valid) {\n\t\t\tthis.buffers = Buffers.getBuffers(gl, this.fragmentString, this.vertexString);\n\t\t\tthis.textureIndex = this.buffers.count;\n\t\t\tthis.vertexBuffers = Context.createVertexBuffers(gl, program);\n\t\t\tthis.createUniforms();\n\t\t\t// this.getBuffers(this.fragmentString);\n\t\t}\n\t\t// Trigger event\n\t\tthis.trigger('load', {});\n\t\t// this.render();\n\t}\n\n\ttest(\n\t\tfragmentString?: string,\n\t\tvertexString?: string\n\t): Promise<any> {\n\t\treturn new Promise((resolve, reject) => {\n\t\t\t// Thanks to @thespite for the help here\n\t\t\t// https://www.khronos.org/registry/webgl/extensions/EXT_disjoint_timer_query/\n\t\t\tconst vertex = this.vertexString;\n\t\t\tconst fragment = this.fragmentString;\n\t\t\tconst paused = this.timer.paused;\n\t\t\tconst extension = this.gl.getExtension('EXT_disjoint_timer_query');\n\t\t\tconst query = extension.createQueryEXT();\n\t\t\tlet wasValid = this.valid;\n\t\t\tif (fragmentString || vertexString) {\n\t\t\t\tthis.load(fragmentString, vertexString);\n\t\t\t\twasValid = this.valid;\n\t\t\t\tthis.render();\n\t\t\t}\n\t\t\tthis.timer.paused = true;\n\t\t\textension.beginQueryEXT(extension.TIME_ELAPSED_EXT, query);\n\t\t\tthis.render();\n\t\t\textension.endQueryEXT(extension.TIME_ELAPSED_EXT);\n\t\t\tconst waitForTest = () => {\n\t\t\t\tthis.render();\n\t\t\t\tconst available = extension.getQueryObjectEXT(query, extension.QUERY_RESULT_AVAILABLE_EXT);\n\t\t\t\tconst disjoint = this.gl.getParameter(extension.GPU_DISJOINT_EXT);\n\t\t\t\tif (available && !disjoint) {\n\t\t\t\t\tconst result = {\n\t\t\t\t\t\twasValid: wasValid,\n\t\t\t\t\t\tfragment: fragmentString || this.fragmentString,\n\t\t\t\t\t\tvertex: vertexString || this.vertexString,\n\t\t\t\t\t\ttimeElapsedMs: extension.getQueryObjectEXT(query, extension.QUERY_RESULT_EXT) / 1000000.0\n\t\t\t\t\t};\n\t\t\t\t\tthis.timer.paused = paused;\n\t\t\t\t\tif (fragmentString || vertexString) {\n\t\t\t\t\t\tthis.load(fragment, vertex);\n\t\t\t\t\t}\n\t\t\t\t\tresolve(result);\n\t\t\t\t} else {\n\t\t\t\t\twindow.requestAnimationFrame(waitForTest);\n\t\t\t\t}\n\t\t\t}\n\t\t\twaitForTest();\n\t\t});\n\t}\n\n\tdestroy(): void {\n\t\tthis.animated = false;\n\t\tthis.valid = false;\n\t\tconst gl = this.gl;\n\t\t/*\n\t\t// !!!\n\t\tfor (let texture in this.textures) {\n\t\t\tif (texture.destroy) {\n\t\t\t\ttexture.destroy(gl);\n\t\t\t}\n\t\t}\n\t\t*/\n\t\tgl.useProgram(null);\n\t\tgl.deleteProgram(this.program);\n\t\tthis.buffers.forEach(buffer => buffer.destroy(gl));\n\t\tthis.buffers = null;\n\t\tthis.textures = null;\n\t\tthis.uniforms = null;\n\t\tthis.program = null;\n\t\tthis.gl = null;\n\t}\n\n\tsetUniform(key: string, ...values: any[]): void {\n\t\tconst uniform: Uniform = Uniforms.parseUniform(key, ...values);\n\t\tif (uniform) {\n\t\t\tif (uniform.type === 'sampler2D') {\n\t\t\t\tthis.loadTexture(key, values[0]);\n\t\t\t} else {\n\t\t\t\tthis.uniforms.set(key, uniform);\n\t\t\t}\n\t\t}\n\t}\n\n\tsetUniforms(values: Map<string, any[]>): void {\n\t\tvalues.forEach((value: any[], key: string) => {\n\t\t\tthis.setUniform(key, ...value);\n\t\t});\n\t}\n\n\tpause(): void {\n\t\tthis.timer.pause();\n\t\tthis.canvas.classList.add('paused');\n\t}\n\n\tplay(): void {\n\t\tthis.timer.play();\n\t\tthis.canvas.classList.remove('paused');\n\t}\n\n\tisVisible(): boolean {\n\t\tconst rect = this.rect;\n\t\treturn (rect.top + rect.height) > 0 && rect.top < (window.innerHeight || document.documentElement.clientHeight);\n\t}\n\n\tisAnimated(): boolean {\n\t\treturn (this.animated || this.textures.animated) && !this.timer.paused;\n\t}\n\n\tisDirty(): boolean {\n\t\treturn this.dirty || this.uniforms.dirty || this.textures.dirty;\n\t}\n\n\t// !!!\n\tsizeDidChanged(): boolean {\n\t\tconst gl = this.gl;\n\t\tconst rect = this.rect;\n\t\tconst W = rect.width,\n\t\t\tH = rect.height;\n\t\tif (this.width !== W ||\n\t\t\tthis.height !== H) {\n\t\t\tthis.width = W;\n\t\t\tthis.height = H;\n\t\t\t// Lookup the size the browser is displaying the canvas in CSS pixels\n\t\t\t// and compute a size needed to make our drawingbuffer match it in\n\t\t\t// device pixels.\n\t\t\tconst BW = Math.floor(W * this.pixelRatio);\n\t\t\tconst BH = Math.floor(H * this.pixelRatio);\n\t\t\t// Check if the canvas is not the same size.\n\t\t\tif (gl.canvas.width !== BW ||\n\t\t\t\tgl.canvas.height !== BH) {\n\t\t\t\t// Make the canvas the same size\n\t\t\t\tgl.canvas.width = BW;\n\t\t\t\tgl.canvas.height = BH;\n\t\t\t\t// Set the viewport to match\n\t\t\t\t// gl.viewport(0, 0, BW, BH);\n\t\t\t}\n\t\t\tthis.buffers.forEach(buffer => {\n\t\t\t\tbuffer.resize(gl, BW, BH);\n\t\t\t});\n\t\t\t// gl.useProgram(this.program);\n\t\t\treturn true;\n\t\t} else {\n\t\t\treturn false;\n\t\t}\n\t}\n\n\tcheckRender(): void {\n\t\tif (this.isVisible() && (this.sizeDidChanged() || this.isAnimated() || this.isDirty())) {\n\t\t\tthis.render();\n\t\t\tthis.canvas.classList.add('playing');\n\t\t} else {\n\t\t\tthis.canvas.classList.remove('playing');\n\t\t}\n\t}\n\n\tcreateUniforms(): void {\n\t\tconst gl = this.gl;\n\t\tconst fragmentString = this.fragmentString;\n\t\tconst BW = gl.drawingBufferWidth;\n\t\tconst BH = gl.drawingBufferHeight;\n\t\tconst timer = this.timer = new GlslCanvasTimer();\n\t\tconst hasDelta = (fragmentString.match(/u_delta/g) || []).length > 1;\n\t\tconst hasTime = (fragmentString.match(/u_time/g) || []).length > 1;\n\t\tconst hasDate = (fragmentString.match(/u_date/g) || []).length > 1;\n\t\tconst hasMouse = (fragmentString.match(/u_mouse/g) || []).length > 1;\n\t\tconst hasTextures = fragmentString.search(/sampler2D/g);\n\t\tthis.animated = hasTime || hasDate || hasMouse;\n\t\tif (this.animated) {\n\t\t\tthis.canvas.classList.add('animated');\n\t\t} else {\n\t\t\tthis.canvas.classList.remove('animated');\n\t\t}\n\t\tthis.uniforms.create('2f', 'vec2', 'u_resolution', BW, BH);\n\t\tif (hasDelta) {\n\t\t\tthis.uniforms.create('1f', 'float', 'u_delta', timer.delta);\n\t\t}\n\t\tif (hasTime) {\n\t\t\tthis.uniforms.create('1f', 'float', 'u_time', timer.current);\n\t\t}\n\t\tif (hasDate) {\n\t\t\tconst date = new Date();\n\t\t\tthis.uniforms.create('4f', 'float', 'u_date', date.getFullYear(), date.getMonth(), date.getDate(), date.getHours() * 3600 + date.getMinutes() * 60 + date.getSeconds() + date.getMilliseconds() * 0.001);\n\t\t}\n\t\tif (hasMouse) {\n\t\t\tthis.uniforms.create('2f', 'vec2', 'u_mouse', 0, 0);\n\t\t}\n\t\tthis.buffers.forEach(buffer => {\n\t\t\tthis.uniforms.create('1i', 'sampler2D', buffer.key, buffer.input.index);\n\t\t});\n\t\tif (hasTextures) {\n\t\t\tconst lines = fragmentString.split('\\n');\n\t\t\tfor (let i = 0; i < lines.length; i++) {\n\t\t\t\tconst match = lines[i].match(/uniform\\s*sampler2D\\s*([\\w]*);\\s*\\/\\/\\s*([\\w|\\:\\/\\/|\\.|\\-|\\_]*)/i);\n\t\t\t\tif (match) {\n\t\t\t\t\tconst ext = match[2].split('.').pop().toLowerCase();\n\t\t\t\t\tconst key = match[1];\n\t\t\t\t\tconst url = match[2];\n\t\t\t\t\tif (key && url && TextureExtensions.indexOf(ext) !== -1) {\n\t\t\t\t\t\tthis.loadTexture(key, url);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tconst main = lines[i].match(/\\s*void\\s*main\\s*/g);\n\t\t\t\tif (main) {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif (this.canvas.hasAttribute('data-textures')) {\n\t\t\tconst urls = this.canvas.getAttribute('data-textures').split(',');\n\t\t\turls.forEach((url: string, i: number) => {\n\t\t\t\tconst key = 'u_tex' + i;\n\t\t\t\tthis.loadTexture(key, url);\n\t\t\t});\n\t\t}\n\t}\n\n\tloadTexture(key: string, url: string): Promise<Texture> {\n\t\treturn this.textures.createOrUpdate(this.gl, key, url, this.buffers.count).then(texture => {\n\t\t\tconst index = texture.index;\n\t\t\tconst uniform = this.uniforms.createTexture(key, index);\n\t\t\tuniform.texture = texture;\n\t\t\tconst uniformResolution = this.uniforms.create('2f', 'vec2', key + 'Resolution', texture.width, texture.height);\n\t\t\t// console.log('loadTexture', key, url, index, texture.width, texture.height);\n\t\t\treturn texture;\n\t\t});\n\t}\n\n\tupdateUniforms(): void {\n\t\tconst gl = this.gl;\n\t\tconst BW = gl.drawingBufferWidth;\n\t\tconst BH = gl.drawingBufferHeight;\n\t\tconst timer = this.timer.next();\n\t\tthis.uniforms.update('2f', 'vec2', 'u_resolution', BW, BH);\n\t\tif (this.uniforms.has('u_delta')) {\n\t\t\tthis.uniforms.update('1f', 'float', 'u_delta', timer.delta);\n\t\t}\n\t\tif (this.uniforms.has('u_time')) {\n\t\t\tthis.uniforms.update('1f', 'float', 'u_time', timer.current);\n\t\t}\n\t\tif (this.uniforms.has('u_date')) {\n\t\t\tconst date = new Date();\n\t\t\tthis.uniforms.update('4f', 'float', 'u_date', date.getFullYear(), date.getMonth(), date.getDate(), date.getHours() * 3600 + date.getMinutes() * 60 + date.getSeconds() + date.getMilliseconds() * 0.001);\n\t\t}\n\t\tif (this.uniforms.has('u_mouse')) {\n\t\t\tconst rect = this.rect;\n\t\t\tconst mouse = this.mouse;\n\t\t\tif (mouse.x >= rect.left && mouse.x <= rect.right &&\n\t\t\t\tmouse.y >= rect.top && mouse.y <= rect.bottom) {\n\t\t\t\tconst MX = (mouse.x - rect.left) * this.pixelRatio;\n\t\t\t\tconst MY = (this.canvas.height - (mouse.y - rect.top) * this.pixelRatio);\n\t\t\t\tthis.uniforms.update('2f', 'vec2', 'u_mouse', MX, MY);\n\t\t\t}\n\t\t}\n\t\tthis.buffers.forEach(buffer => {\n\t\t\tthis.uniforms.update('1i', 'sampler2D', buffer.key, buffer.input.index);\n\t\t});\n\t\tthis.textures.forEach(texture => {\n\t\t\ttexture.tryUpdate(gl);\n\t\t\tthis.uniforms.update('1i', 'sampler2D', texture.key, texture.index);\n\t\t});\n\t}\n\n\trender(): void {\n\t\tconst gl = this.gl;\n\t\tconst BW = gl.drawingBufferWidth;\n\t\tconst BH = gl.drawingBufferHeight;\n\t\tthis.updateUniforms();\n\t\tthis.buffers.forEach(buffer => {\n\t\t\tthis.uniforms.apply(gl, buffer.program);\n\t\t\tbuffer.render(gl, BW, BH);\n\t\t});\n\t\tgl.useProgram(this.program);\n\t\tthis.uniforms.apply(gl, this.program);\n\t\tgl.viewport(0, 0, BW, BH);\n\t\tgl.bindFramebuffer(gl.FRAMEBUFFER, null);\n\t\tgl.drawArrays(gl.TRIANGLES, 0, 6);\n\t\tthis.uniforms.forEach(uniform => uniform.dirty = false);\n\t\tthis.uniforms.dirty = false;\n\t\tthis.textures.forEach(texture => texture.dirty = false);\n\t\tthis.textures.dirty = false;\n\t\tthis.dirty = false;\n\t\tthis.trigger('render', {});\n\t}\n\n}\n\n(<any>window).GlslCanvas = GlslCanvas;\n\nconst loadAllGlslCanvas = () => {\n\tconst canvases: HTMLCanvasElement[] = <HTMLCanvasElement[]>Array.from(document.getElementsByClassName('glslCanvas')).filter(x => x instanceof HTMLCanvasElement);\n\t(<any>window).glslCanvases = canvases.map(x => {\n\t\treturn new GlslCanvas(x);\n\t}).filter(x => x.valid);\n}\n\nwindow.addEventListener('load', () => {\n\tloadAllGlslCanvas();\n});\n"],"file":"glsl-canvas.js"}